Perfect. Here is a clean, complete, no-BS summary of HRP, with every main step and the exact math used at each step, in the correct order.

Read this as your mental checklist for HRP.

âœ… HIERARCHICAL RISK PARITY (HRP): COMPLETE STEP-BY-STEP SUMMARY
ğŸ”¹ INPUTS (what you start with)

For N assets, you need only:

Volatility vector

ğœ
=
(
ğœ
1
,
â€¦
,
ğœ
ğ‘
)
Ïƒ=(Ïƒ
1
	â€‹

,â€¦,Ïƒ
N
	â€‹

)

Correlation matrix

ğœŒ
âˆˆ
ğ‘…
ğ‘
Ã—
ğ‘
ÏâˆˆR
NÃ—N

Thatâ€™s it.
âŒ No expected returns
âŒ No optimization
âŒ No matrix inversion (yet)

STEP 1ï¸âƒ£ â€” Correlation â†’ Distance (make clustering possible)

Clustering algorithms need distances, not correlations.

Formula (used for every pair 
ğ‘–
,
ğ‘—
i,j):
ğ‘‘
ğ‘–
ğ‘—
=
1
âˆ’
ğœŒ
ğ‘–
ğ‘—
2
d
ij
	â€‹

=
2
1âˆ’Ï
ij
	â€‹

	â€‹

	â€‹

	â€‹

Output:

Distance matrix 
ğ·
âˆˆ
ğ‘…
ğ‘
Ã—
ğ‘
DâˆˆR
NÃ—N

Properties:

ğ‘‘
ğ‘–
ğ‘—
â‰¥
0
d
ij
	â€‹

â‰¥0

ğ‘‘
ğ‘–
ğ‘—
=
ğ‘‘
ğ‘—
ğ‘–
d
ij
	â€‹

=d
ji
	â€‹


ğ‘‘
ğ‘–
ğ‘–
=
0
d
ii
	â€‹

=0

ğŸ“Œ Interpretation:

High correlation â†’ small distance

Low / negative correlation â†’ large distance

STEP 2ï¸âƒ£ â€” Hierarchical Clustering (build the risk tree)

Using the distance matrix, perform agglomerative hierarchical clustering.

Algorithm:

Start with N single-asset clusters

Repeatedly:

Find the closest pair of clusters

Merge them

Continue until 1 cluster (root) remains

ğŸ”— Cluster distance (Average Linkage â€” HRP standard)

For two clusters 
ğ¶
1
,
ğ¶
2
C
1
	â€‹

,C
2
	â€‹

:

ğ‘‘
(
ğ¶
1
,
ğ¶
2
)
=
1
âˆ£
ğ¶
1
âˆ£
â€‰
âˆ£
ğ¶
2
âˆ£
âˆ‘
ğ‘–
âˆˆ
ğ¶
1
âˆ‘
ğ‘—
âˆˆ
ğ¶
2
ğ‘‘
ğ‘–
ğ‘—
d(C
1
	â€‹

,C
2
	â€‹

)=
âˆ£C
1
	â€‹

âˆ£âˆ£C
2
	â€‹

âˆ£
1
	â€‹

iâˆˆC
1
	â€‹

âˆ‘
	â€‹

jâˆˆC
2
	â€‹

âˆ‘
	â€‹

d
ij
	â€‹

	â€‹


ğŸ“Œ This step uses only distances, nothing else.

Output:

A binary tree (dendrogram)

Leaves = assets

Internal nodes = merged clusters

Clustering stops only when the root is formed.

STEP 3ï¸âƒ£ â€” Quasi-Diagonalization (ordering, not math-heavy)

Reorder assets according to the tree leaf order, so that:

Correlated assets are adjacent

Covariance matrix becomes block-structured

ğŸ“Œ This is for numerical stability and recursion order.

(No new math here â€” just reordering.)

STEP 4ï¸âƒ£ â€” Compute Covariance Matrix (needed for risk)

Before allocating, compute covariance:

Î£
ğ‘–
ğ‘—
=
ğœŒ
ğ‘–
ğ‘—
â€‰
ğœ
ğ‘–
â€‰
ğœ
ğ‘—
Î£
ij
	â€‹

=Ï
ij
	â€‹

Ïƒ
i
	â€‹

Ïƒ
j
	â€‹

	â€‹


This matrix is used only for risk computation, not optimization.

STEP 5ï¸âƒ£ â€” Compute Cluster Volatility (core HRP math)

For any cluster 
ğ¶
C:

1ï¸âƒ£ Internal weights (inverse-vol rule)
ğ‘¤
ğ‘–
=
1
/
ğœ
ğ‘–
âˆ‘
ğ‘—
âˆˆ
ğ¶
1
/
ğœ
ğ‘—
w
i
	â€‹

=
âˆ‘
jâˆˆC
	â€‹

1/Ïƒ
j
	â€‹

1/Ïƒ
i
	â€‹

	â€‹

	â€‹

2ï¸âƒ£ Cluster variance
ğœ
ğ¶
2
=
ğ‘¤
âŠ¤
Î£
ğ¶
ğ‘¤
Ïƒ
C
2
	â€‹

=w
âŠ¤
Î£
C
	â€‹

w
	â€‹

3ï¸âƒ£ Cluster volatility
ğœ
ğ¶
=
ğœ
ğ¶
2
Ïƒ
C
	â€‹

=
Ïƒ
C
2
	â€‹

	â€‹

	â€‹


ğŸ“Œ This answers:

â€œHow risky is this cluster if capital is spread evenly by risk inside it?â€

STEP 6ï¸âƒ£ â€” Recursive Bisection (allocate capital)

Now HRP walks the tree from top to bottom.

At each split:

Parent cluster
â”œâ”€â”€ Left child
â””â”€â”€ Right child

Allocation rule (THIS IS THE KEY FORMULA)

If left and right clusters have volatilities 
ğœ
ğ¿
,
ğœ
ğ‘…
Ïƒ
L
	â€‹

,Ïƒ
R
	â€‹

:

ğ‘¤
ğ¿
=
ğœ
ğ‘…
ğœ
ğ¿
+
ğœ
ğ‘…
,
ğ‘¤
ğ‘…
=
ğœ
ğ¿
ğœ
ğ¿
+
ğœ
ğ‘…
w
L
	â€‹

=
Ïƒ
L
	â€‹

+Ïƒ
R
	â€‹

Ïƒ
R
	â€‹

	â€‹

,w
R
	â€‹

=
Ïƒ
L
	â€‹

+Ïƒ
R
	â€‹

Ïƒ
L
	â€‹

	â€‹

	â€‹


ğŸ“Œ Riskier cluster â†’ less capital
ğŸ“Œ Safer cluster â†’ more capital

Apply recursively:

Root â†’ 2 clusters

Each cluster â†’ its children

Continue until individual assets

Final asset weight = product of weights along its path

STEP 7ï¸âƒ£ â€” Final Output

You now have:

ğ‘¤
=
(
ğ‘¤
1
,
â€¦
,
ğ‘¤
ğ‘
)
w=(w
1
	â€‹

,â€¦,w
N
	â€‹

)
	â€‹


Properties:

Fully invested

Risk-diversified by structure

No expected returns

Stable under estimation error

ğŸ§  ONE-PAGE MENTAL MODEL (MEMORIZE THIS)
Correlation
   â†“
Distance
   â†“
Hierarchical clustering (build tree)
   â†“
Compute cluster risk (portfolio volatility)
   â†“
Recursive bisection (inverse-risk allocation)
   â†“
Final weights